<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>垃圾回收算法 | Esen</title>
<link rel="shortcut icon" href="https://esencool.github.io//favicon.ico?v=1718774120551">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://esencool.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="垃圾回收算法 | Esen - Atom Feed" href="https://esencool.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="算法的评价标准
吞吐量
在单位时间内的处理能力。result=HEAP_SIZE/∑GCtimeresult = HEAP\_SIZE/\sum GC_{time}result=HEAP_SIZE/∑GCtime​
在计算吞吐量的时候，也需..." />
    <meta name="keywords" content="技术文章" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://esencool.github.io/">
  <img class="avatar" src="https://esencool.github.io//images/avatar.png?v=1718774120551" alt="">
  </a>
  <h1 class="site-title">
    Esen
  </h1>
  <p class="site-description">
    且共从容
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/esencool" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              垃圾回收算法
            </h2>
            <div class="post-info">
              <span>
                2024-06-12
              </span>
              <span>
                5 min read
              </span>
              
                <a href="https://esencool.github.io/tag/Ab380PTf0/" class="post-tag">
                  # 技术文章
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h2 id="算法的评价标准">算法的评价标准</h2>
<h3 id="吞吐量">吞吐量</h3>
<p>在单位时间内的处理能力。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mo>=</mo><mi>H</mi><mi>E</mi><mi>A</mi><mi>P</mi><mi mathvariant="normal">_</mi><mi>S</mi><mi>I</mi><mi>Z</mi><mi>E</mi><mi mathvariant="normal">/</mi><mo>∑</mo><mi>G</mi><msub><mi>C</mi><mrow><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">result = HEAP\_SIZE/\sum GC_{time}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">/</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">G</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
在计算吞吐量的时候，也需要考虑程序的运行状态。同一算法在不同的运行情况下吞吐量是不固定的。</p>
<h3 id="最大暂停时间">最大暂停时间</h3>
<p>字面意义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mo>=</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>G</mi><msub><mi>C</mi><mrow><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">result= \min(GC_{time})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
较大的吞吐量与较短的最大暂停时间不可兼得。</p>
<h3 id="堆使用效率">堆使用效率</h3>
<p>可用的堆越大，GC运行越快。</p>
<h3 id="访问的局部性">访问的局部性</h3>
<p>内存对象具有访问局部性，把具有引用关系的对象安排在堆中较近的位置，能提高缓存的利用效率。</p>
<h2 id="gc标记-清除算法">GC标记-清除算法</h2>
<p>顾名思义，算法由两个阶段构成，分别为标记阶段与清除阶段。</p>
<h3 id="标记阶段">标记阶段</h3>
<p>标记根直接引用的对象。即递归的标记所有可达对象。</p>
<blockquote>
<p>根：对象指针的起点。再分配对象内存时，对象的指针会被根节点关联。被根引用的对象是活动对象，需要被保护。</p>
</blockquote>
<ol>
<li>在标记时，需要处理循环情况，使用<code>set</code>避免死循环。</li>
<li>在搜索时，使用的是DFS深度优先搜索，因为这样可以压低内存使用量。</li>
</ol>
<blockquote>
<p>DFS内存使用取决于树的高度，BFS取决于叶子节点的数量。</p>
</blockquote>
<h3 id="清除阶段">清除阶段</h3>
<p>便利整个堆，回收没有打上标记的对象。<br>
花费的时间与堆的大小成正比，堆越大，话费的时间越长</p>
<h4 id="分配">分配</h4>
<ol>
<li>first fit ：发现的第一个大于等于<code>size</code>的分块</li>
<li>best-fit ： 遍历整个链表，返回大于等于<code>size</code>的最小分快</li>
</ol>
<p>从时间来讲，first fit更优。best fit 会让空闲列表更加紧凑</p>
<h4 id="合并">合并</h4>
<p>如果分块连续，则对其进行合并。</p>
<h3 id="分析">分析</h3>
<h4 id="优点">优点</h4>
<p>简单，实现容易。更容易与其他算法相组合。<br>
算法不移动对象，非常适合保守式的算法。</p>
<h4 id="缺点">缺点</h4>
<p>与文件系统相似，会逐渐产生内存碎片。对于应用程序的执行造成负担。</p>
<h4 id="分配速度">分配速度</h4>
<p>算法黄总分块是不连续的，每次分配都需要遍历空闲链表，找到足够大的分块，可能导致每次分配都需要线性时间。</p>
<h4 id="与写时复制技术不兼容-copy-on-write">与写时复制技术不兼容 copy-on-write</h4>
<p>在堆共享内存进行写入时，不能直接重写共享内存。如果其他程序访问，会发生数据不一致的情况。<br>
标记清除算法会设置所有对象的标志位，会频繁发生复制情况。使用<a href="#ftq2e">bitmap markin</a>g方法解决。</p>
<h4 id="使用多个空闲列表来优化分配">使用多个空闲列表来优化分配</h4>
<p>程序通常会频繁申请分配小分快，因此可以使用多个空闲链表对齐进行预处理</p>
<h4 id="bibopbig-bag-of-pages">BiBOP（Big Bag of Pages）</h4>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/43081260/1718007673350-84a79279-0454-4285-9ac9-e25d00c03e59.png#averageHue=%23f9f9f8&amp;clientId=u9ce8d5a0-8b7d-4&amp;from=paste&amp;height=342&amp;id=u86c03ff4&amp;originHeight=342&amp;originWidth=580&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=46571&amp;status=done&amp;style=none&amp;taskId=u6c0c4fb5-1f09-4d6b-9282-760c2c222a2&amp;title=&amp;width=580" alt="image.png" loading="lazy"><br>
并不能完全消除碎片化，如果多个块中分散残留着相同大小的对象，反而降低堆使用效率。</p>
<h4 id="bitmap-marking">bitmap marking</h4>
<ol>
<li>为了避免频繁的写时复制，将存储于对象的标志位集中到bitmap中，由于bitmap很小，写时复制没有问题。</li>
<li>对于清除阶段，可以避免遍历整个堆，只需要使用位运算快速的定位到需要被标记的对象。</li>
</ol>
<h4 id="延迟清除">延迟清除</h4>
<h2 id="引用技术法-reference-counting">引用技术法 Reference Counting</h2>
<h3 id="计数器">计数器</h3>
<p>在内存管理时，会同时增减计数器的值。<br>
<img src="https://cdn.nlark.com/yuque/0/2024/png/43081260/1718008206659-c2a3532c-56c9-4e2e-adb8-f0d766f0925c.png#averageHue=%23f7f7f6&amp;clientId=u9ce8d5a0-8b7d-4&amp;from=paste&amp;height=206&amp;id=u535175a4&amp;originHeight=206&amp;originWidth=529&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=35473&amp;status=done&amp;style=none&amp;taskId=ude28615a-ef05-44e9-9409-ec293b5a86d&amp;title=&amp;width=529" alt="image.png" loading="lazy"><br>
在垃圾回收时，会将计数器为0的项与空闲链表链接。</p>
<h3 id="分析-2">分析</h3>
<h4 id="优点-2">优点</h4>
<ol>
<li>可以立刻回收对象，而不是分块用尽之后</li>
<li>最大暂停时间短，在程序更新指针时才进行回收</li>
<li>不必要递归查找</li>
</ol>
<h4 id="缺点-2">缺点</h4>
<ol>
<li>计算器的值增减十分复杂。</li>
<li>计数器需要占据较大空间，如果是64位机器需要使用64位来存储计数器</li>
<li>实现十分繁琐</li>
<li>无法回收循环引用</li>
</ol>
<h3 id="改良">改良</h3>
<h4 id="延迟引用计数">延迟引用计数</h4>
<p>解决增减处理繁琐的问题，将计数为0的对象延迟回收，减轻每次根节点发生变化的负担。<br>
但会导致垃圾的处理被延迟阻塞执行，会导致垃圾处理时间变长，降低了吞吐量，也失去了可立即回收的优点</p>
<h4 id="sticky-引用计数法">sticky 引用计数法</h4>
<p>上面提到如果64位机器需要使用64位来存储计数器，那么有什么办法节约这些空间吗？</p>
<ol>
<li>当计数器溢出的时候，什么都不做——就让他放着，因为这些场景很少。</li>
<li>使用标记清除法做后援：
<ol>
<li>溢出后的对象使用标记清除算法进行释放，但这样会导致花更多时间，降低吞吐量</li>
</ol>
</li>
</ol>
<h4 id="1-bit-reference-counting">1 bit reference counting</h4>
<p>简化标记变成1位，可以有效利用内存访问的局限性。<br>
但没办法处理溢出场景</p>
<h4 id="部分标记清除算法">部分标记清除算法</h4>
<h2 id="gc复制算法">GC复制算法</h2>
<h3 id="优点-3">优点</h3>
<ol>
<li>优秀的吞吐量：算法只搜索并复制活动对象，可以在较短时间完成GC</li>
<li>可实现高速分配：不使用空闲链表，可以快速分配新的空间</li>
<li>没有碎片化问题：活跃对象压缩至堆一端，无内存碎片的问题</li>
<li>适用高速缓存：有引用关系的对象会被放到一起</li>
</ol>
<h3 id="缺点-3">缺点</h3>
<ol>
<li>堆使用效率低下：二等分了堆，导致安排对象的空间只有一半</li>
<li>不兼容保守式GC：需要对对象移动位置</li>
<li>递归调用函数</li>
</ol>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86">算法的评价标准</a>
<ul>
<li><a href="#%E5%90%9E%E5%90%90%E9%87%8F">吞吐量</a></li>
<li><a href="#%E6%9C%80%E5%A4%A7%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4">最大暂停时间</a></li>
<li><a href="#%E5%A0%86%E4%BD%BF%E7%94%A8%E6%95%88%E7%8E%87">堆使用效率</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7">访问的局部性</a></li>
</ul>
</li>
<li><a href="#gc%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95">GC标记-清除算法</a>
<ul>
<li><a href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5">标记阶段</a></li>
<li><a href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5">清除阶段</a>
<ul>
<li><a href="#%E5%88%86%E9%85%8D">分配</a></li>
<li><a href="#%E5%90%88%E5%B9%B6">合并</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E6%9E%90">分析</a>
<ul>
<li><a href="#%E4%BC%98%E7%82%B9">优点</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9">缺点</a></li>
<li><a href="#%E5%88%86%E9%85%8D%E9%80%9F%E5%BA%A6">分配速度</a></li>
<li><a href="#%E4%B8%8E%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E6%8A%80%E6%9C%AF%E4%B8%8D%E5%85%BC%E5%AE%B9-copy-on-write">与写时复制技术不兼容 copy-on-write</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E6%9D%A5%E4%BC%98%E5%8C%96%E5%88%86%E9%85%8D">使用多个空闲列表来优化分配</a></li>
<li><a href="#bibopbig-bag-of-pages">BiBOP（Big Bag of Pages）</a></li>
<li><a href="#bitmap-marking">bitmap marking</a></li>
<li><a href="#%E5%BB%B6%E8%BF%9F%E6%B8%85%E9%99%A4">延迟清除</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%BC%95%E7%94%A8%E6%8A%80%E6%9C%AF%E6%B3%95-reference-counting">引用技术法 Reference Counting</a>
<ul>
<li><a href="#%E8%AE%A1%E6%95%B0%E5%99%A8">计数器</a></li>
<li><a href="#%E5%88%86%E6%9E%90-2">分析</a>
<ul>
<li><a href="#%E4%BC%98%E7%82%B9-2">优点</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9-2">缺点</a></li>
</ul>
</li>
<li><a href="#%E6%94%B9%E8%89%AF">改良</a>
<ul>
<li><a href="#%E5%BB%B6%E8%BF%9F%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">延迟引用计数</a></li>
<li><a href="#sticky-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95">sticky 引用计数法</a></li>
<li><a href="#1-bit-reference-counting">1 bit reference counting</a></li>
<li><a href="#%E9%83%A8%E5%88%86%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95">部分标记清除算法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#gc%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95">GC复制算法</a>
<ul>
<li><a href="#%E4%BC%98%E7%82%B9-3">优点</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9-3">缺点</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://esencool.github.io/post/wen-ding-xing/">
              <h3 class="post-title">
                稳定性
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://esencool.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
